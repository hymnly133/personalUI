# 任务：智能合并增量更新

你是一个知识图谱合并专家，负责将新的增量更新智能合并到现有的知识图谱中。

## 当前System和Graph状态

### 当前System定义
```yaml
{current_system}
```

### 当前Graph摘要
- 实体数量: {entity_count}
- 关系数量: {relationship_count}

### 所有现有实体详情（完整列表，不包含关系）
以下是当前图谱中的所有实体信息，包括实体名称、描述、所属类和属性值：

```json
{existing_entities_full}
```

### Delta相关的现有数据（模糊搜索结果）
以下是通过对待合并delta中每个实体进行模糊搜索后，找到的可能相关的现有实体。
这些数据已去重合并，按相关度排序。每个实体标记了是由delta中的哪个实体搜索得到的（matched_by字段）。

```json
{delta_related_data}
```

**说明**：
- 如果delta_related_data中有实体与delta中的实体名称完全相同或非常相似，说明该实体很可能已存在于图谱中
- search_score表示相关度得分（0-1），得分越高说明越相关

## 待合并的增量更新

```json
{delta}
```

## 合并任务

请分析待合并的增量更新，充分利用提供的现有数据进行智能合并：

### 0. 数据理解与对照
在开始合并前，先理解提供的数据：
- **所有现有实体详情**: 包含当前图谱中的所有实体，你应该用这些数据来判断实体是否已存在
- **Delta相关的现有数据**: 这是针对delta中每个实体的模糊搜索结果，重点关注：
  - 如果搜索结果中有与delta实体名称相同或高度相似的实体，说明该实体很可能已存在
  - search_score越高，说明相关性越强
- **对照策略**: 
  1. 对于delta中的每个实体，先在"Delta相关的现有数据"中查找是否有相关实体
  2. 如果找到高相关度的实体（search_score > 0.5或名称非常相似），再到"所有现有实体详情"中查看完整信息
  3. 基于完整信息做出合并决策

### 1. 去重识别
识别增量中与现有图谱重复的实体和关系：
- **优先查看Delta相关数据**: 首先检查"Delta相关的现有数据"中是否已有该实体
- 检查实体名称的同义词、缩写、不同表达方式
- 识别本质相同但描述不同的实体
- 如果delta实体在"所有现有实体详情"中存在，operation应设为"update"或"skip"而非"add"
- 检查重复的关系

### 2. 命名对齐
统一命名规范：
- 如果增量中的实体与现有实体是同一个，使用现有实体的名称
- 如果是新实体但命名不规范，优化命名
- 确保命名简洁、准确、一致

### 3. 冲突解决
处理属性值冲突：
- 如果同一实体的同一属性有不同值，选择更准确的值
- 如果无法判断，保留两个值并添加说明
- 合并互补的描述信息

### 4. 描述优化
优化实体和关系的描述：
- 合并重复信息
- 保留关键细节
- 使描述更加精准和完整

### 5. 操作决策
为每个增量项决定最终操作：
- "add": 全新的实体/关系，直接添加
- "merge": 与现有项合并，需要指定merge_target（目标实体名）
- "update": 更新现有项的属性/描述
- "skip": 完全重复，跳过
- "increment_count": 【仅用于关系】增量中的关系与现有关系语义完全相同（source、target、description、refer都相同），只需累加count，不添加新关系

## 输出格式

请严格按照以下JSON格式输出（不要添加任何markdown标记）：

```json
{{
  "optimized_classes": [
    {{
      "name": "类名",
      "description": "优化后的描述",
      "properties": [
        {{
          "name": "属性名",
          "description": "属性描述",
          "required": false,
          "value_required": false,
          "operation": "add"
        }}
      ],
      "operation": "add"
    }}
  ],
  "optimized_entities": [
    {{
      "name": "优化后的实体名",
      "original_name": "原始实体名（如果修改了）",
      "description": "优化后的描述",
      "classes": ["类名1", "类名2"],
      "properties": {{
        "类名": {{
          "属性名": "属性值"
        }}
      }},
      "operation": "add",
      "merge_target": null,
      "reason": "操作原因说明"
    }}
  ],
  "optimized_relationships": [
    {{
      "source": "源实体名",
      "target": "目标实体名",
      "description": "优化后的关系描述",
      "count": 1,
      "refer": ["参与实体1", "参与实体2"],
      "semantic_times": ["2026-01-10T10:30:00"],
      "operation": "add",
      "merge_target": null,
      "reason": "操作原因说明",
      "increment_amount": 0
    }}
  ],
  "merge_summary": {{
    "duplicates_found": 2,
    "conflicts_resolved": 1,
    "names_aligned": 3,
    "descriptions_optimized": 5,
    "notes": "合并过程的总体说明"
  }}
}}
```

## 重要规则

1. **去重优先**: 宁可保守合并，也不要创建重复实体
2. **增量累加优先**: 如果关系与现有关系语义上完全相同，使用increment_count操作累加次数
3. **保留现有命名**: 如果实体已存在，使用现有名称
4. **信息不丢失**: 合并时不要丢失有价值的信息
5. **操作明确**: 每个项必须有明确的operation和reason
6. **JSON格式**: 输出必须是有效的JSON，不要添加任何其他内容

## 【严重警告】实体节点 vs 类节点：永远不要混淆！

**这是最关键的规则，违反此规则会导致严重的数据损坏！**

### 核心概念

在知识图谱系统中，有两种完全不同的节点类型：

1. **实体节点（Entity Node）**
   - 格式：`实体名`（不含冒号）
   - 示例：`张三的店`、`小红书`、`我`
   - 表示：一个具体的实体对象
   
2. **类节点（Class Node / Entity:Class Node）**
   - 格式：`实体名:类名`（含冒号）
   - 示例：`张三的店:商家`、`小红书:购物平台`、`我:用户`
   - 表示：该实体作为某个类的一个实例，是实体的特定方面

### 【关键】实体节点和类节点必须共存

**正确的结构**：
```json
// 实体节点
{{"name": "张三的店", "classes": ["商家", "现实地点"]}}

// 对应的类节点（自动生成）
// - 张三的店:商家
// - 张三的店:现实地点

// 关系可以指向实体节点或类节点
{{"source": "我", "target": "张三的店"}}  // 整体关系
{{"source": "我", "target": "张三的店:商家"}}  // 功能性关系
```

### 【严重错误】绝对不能做的事

❌ **错误 1：将类节点视为实体节点**
```json
// 错误：将"张三的店:商家"当作实体名
{{"name": "张三的店:商家", "classes": ["商家"]}}  // 大错特错！

// 正确：这是一个类节点引用，不是实体定义
// 实体定义是：{{"name": "张三的店", "classes": ["商家"]}}
```

❌ **错误 2：将类节点合并到实体节点**
```json
// 增量数据
{{"source": "我", "target": "张三的店:商家"}}

// 现有实体
{{"name": "张三的店"}}

// ❌ 错误操作：认为"张三的店:商家"应该合并到"张三的店"实体
// ✅ 正确操作：保持原样！"张三的店:商家"是类节点引用，不需要合并
```

❌ **错误 3：删除类节点引用的冒号部分**
```json
// 增量关系
{{"source": "我", "target": "张三的店:商家"}}

// ❌ 错误：将target修改为"张三的店"（删除了":商家"部分）
// ✅ 正确：保持"张三的店:商家"不变
```

### 【正确做法】识别和处理类节点引用

#### 识别方法

检查字符串中是否包含冒号 `:`:
- **包含冒号** → 这是类节点引用（`实体名:类名`）
- **不包含冒号** → 这是实体节点引用（`实体名`）

#### 处理规则

**规则 A：在关系的 source、target、refer 中**
```json
// 如果遇到"张三的店:商家"
1. 识别：这是类节点引用
2. 检查：实体"张三的店"是否存在
3. 检查：实体"张三的店"是否有"商家"类
4. 处理：
   a) 如果实体存在且有该类 → 保持"张三的店:商家"不变
   b) 如果实体存在但没有该类 → 可能需要添加该类到实体
   c) 如果实体不存在 → 需要创建实体并添加该类
5. 输出：保持关系中的"张三的店:商家"格式不变
```

**规则 B：绝对不要做的事**
```
❌ 不要将"张三的店:商家"作为实体名添加到 optimized_entities 中
❌ 不要将"张三的店:商家"合并到"张三的店"实体
❌ 不要将关系中的"张三的店:商家"修改为"张三的店"
❌ 不要创建名为"张三的店:商家"的实体（含冒号的不是实体名！）
```

### 【示例】正确的合并处理

#### 场景 1：增量包含类节点引用

**增量数据**：
```json
{{
  "entities": [
    {{"name": "张三的店", "classes": ["商家"]}}
  ],
  "relationships": [
    {{"source": "我", "target": "张三的店:商家", "description": "我在张三的店购物"}}
  ]
}}
```

**现有数据**：
```json
{{
  "entities": [
    {{"name": "张三的店", "classes": ["餐厅"]}}
  ]
}}
```

**正确的输出**：
```json
{{
  "optimized_entities": [
    {{
      "name": "张三的店",
      "classes": ["餐厅", "商家"],
      "operation": "update",
      "reason": "增量中新增了'商家'类，与现有'餐厅'类合并"
    }}
  ],
  "optimized_relationships": [
    {{
      "source": "我",
      "target": "张三的店:商家",
      "description": "我在张三的店购物",
      "operation": "add",
      "reason": "新增关系，target保持类节点格式"
    }}
  ]
}}
```

**注意**：
- ✅ 关系中的`"张三的店:商家"`保持不变（包含冒号）
- ✅ 实体定义中的`"name": "张三的店"`不含冒号
- ✅ 实体的classes数组中添加了"商家"

#### 场景 2：避免错误合并

**增量关系**：
```json
{{"source": "美团外卖:购物平台", "target": "张三的店的招牌套餐:商品"}}
```

**错误处理** ❌：
```json
// 将类节点引用错误地理解为需要创建的实体
{{
  "optimized_entities": [
    {{"name": "美团外卖:购物平台", "operation": "add"}}  // 大错！
  ]
}}
```

**正确处理** ✅：
```json
// 检查实体"美团外卖"是否存在，检查是否有"购物平台"类
{{
  "optimized_entities": [
    // 如果需要，创建或更新实体（不含冒号）
    {{"name": "美团外卖", "classes": ["购物平台"], "operation": "..."}}
  ],
  "optimized_relationships": [
    {{  
      "source": "美团外卖:购物平台",  // 保持冒号格式
      "target": "张三的店的招牌套餐:商品",  // 保持冒号格式
      "operation": "add"
    }}
  ]
}}
```

### 【检查清单】合并前必须确认

在输出 optimized_entities 之前，检查每个实体名称：

1. ✓ 是否包含冒号 `:`？
   - 如果是 → **这不是实体名！这是类节点引用！不要添加到 optimized_entities！**
   - 如果否 → 可以继续处理
   
2. ✓ 在 optimized_relationships 中：
   - source、target、refer 中的值可以包含冒号（类节点引用）
   - 这些值应该保持原样，不要删除冒号部分
   
3. ✓ 在 optimized_entities 中：
   - name 字段**绝对不能**包含冒号
   - 如果看到冒号，说明你犯了严重错误

### 【记忆口诀】

```
实体名称：不含冒号
类节点引用：含冒号
关系中可用：类节点引用
实体定义中：只用实体名

"张三的店" = 实体（可以在 optimized_entities 中）
"张三的店:商家" = 类节点引用（不能在 optimized_entities 中！）
```

## 【关键】实体重定向规则

**背景**: Delta数据可能基于较旧的system版本生成，而当前system已经更新，导致实体类型不匹配。

**问题场景示例**:
- 任务1: 提取"张三的店:餐厅" → 已合并到当前graph
- 任务2: 基于旧system（没有"张三的店"）提取"张三的店:地点"，并包含关系 "好评:内容 -> 张三的店:地点"
- 合并任务2时，当前graph已有"张三的店:餐厅"
- **正确做法**: 将任务2中的"张三的店:地点"重定向为"张三的店:餐厅"

**重定向规则**:

### 5.1 检测需要重定向的实体
- 如果增量中的实体名称与现有实体名称相同，但类不同（如 "张三的店:地点" vs "张三的店:餐厅"）
- 这表明delta基于旧版本生成，需要重定向到现有实体的类

### 5.2 实体重定向优先级
1. **优先使用现有实体的类**: 如果现有graph中已有该实体且有类，使用现有的类
2. **类合并**: 如果两个类都有价值，可以将delta的类作为额外的类添加到实体
3. **选择更具体的类**: 如果需要选择，选择更具体、更准确的类（如"餐厅"比"地点"更具体）

### 5.3 关系重定向

**关键理解**：
- 在关系中，`"张三的店:地点"` 和 `"张三的店:餐厅"` 都是**类节点引用**（含冒号）
- 它们引用的是同一个实体 `"张三的店"` 的不同类
- 重定向是指：将引用改为指向更准确的类

**重定向规则**：
1. **识别类节点引用**：检查是否包含冒号
2. **提取实体名和类名**：`"张三的店:地点"` → 实体=`"张三的店"`，类=`"地点"`
3. **检查现有实体的类**：查看实体 `"张三的店"` 有哪些类
4. **选择目标类**：
   - 如果现有实体有更准确的类（如`"餐厅"`），使用该类
   - 否则，保持增量中的类或添加新类
5. **更新关系引用**：将类节点引用更新为正确的格式

**示例**：
- 增量关系: `"好评:内容"` -> `"张三的店:地点"`（类节点引用）
- 现有实体: `{{"name": "张三的店", "classes": ["餐厅"]}}`
- 分析：`"张三的店:地点"` 引用的是实体 `"张三的店"` 的 `"地点"` 类
- 现有实体有更准确的类 `"餐厅"`
- 重定向后: `"好评:内容"` -> `"张三的店:餐厅"`（更准确的类节点引用）

**注意**：
- ✅ 重定向是改变**类节点引用**中的类部分
- ❌ 不是将**类节点引用**改为**实体节点**（不要删除冒号！）
- ❌ 不是创建名为 `"张三的店:地点"` 的实体（含冒号的不是实体名！）

### 5.4 重定向处理步骤
1. **识别重复实体**: 扫描增量中的所有实体，检查是否与现有实体同名但类不同
2. **决定目标类**: 根据现有实体的类和增量实体的类，决定最终使用哪个类
3. **更新实体**: 如果需要，将增量实体标记为"merge"操作，merge_target为现有实体名:现有类名
4. **更新所有关系**: 遍历所有关系，将引用旧实体:类的地方替换为新实体:类
5. **记录原因**: 在reason字段中说明进行了重定向以及原因

### 5.5 重定向示例

**场景**: 
- 现有实体: `{{"name": "张三的店", "classes": ["餐厅"]}}`
- 增量实体: `{{"name": "张三的店", "classes": ["地点"]}}`
- 增量关系: `{{"source": "好评:内容", "target": "张三的店:地点"}}`

**分析**：
1. 增量中的实体定义：`"张三的店"` 有类 `["地点"]`
2. 现有实体定义：`"张三的店"` 有类 `["餐厅"]`
3. 增量中的关系：引用类节点 `"张三的店:地点"`（含冒号，这是类节点引用！）
4. 决策：`"餐厅"` 比 `"地点"` 更具体，使用现有的类
5. 重定向：将关系中的类节点引用从 `"张三的店:地点"` 改为 `"张三的店:餐厅"`

**输出**:
```json
{{
  "optimized_entities": [
    {{
      "name": "张三的店",
      "classes": ["餐厅"],
      "operation": "skip",
      "reason": "实体已存在，类型为'餐厅'比增量中的'地点'更具体，保持现有类型"
    }}
  ],
  "optimized_relationships": [
    {{
      "source": "好评:内容",
      "target": "张三的店:餐厅",
      "operation": "add",
      "reason": "重定向类节点引用：原为'张三的店:地点'，现有实体的类为'餐厅'更准确，重定向为'张三的店:餐厅'"
    }}
  ]
}}
```

**关键要点**：
- ✅ 实体定义的 `name` 字段：`"张三的店"`（不含冒号）
- ✅ 关系中的 `target`：`"张三的店:餐厅"`（含冒号，类节点引用）
- ✅ 重定向只改变类节点引用的类部分（从 `:地点` 到 `:餐厅`）
- ❌ 绝不创建名为 `"张三的店:地点"` 或 `"张三的店:餐厅"` 的实体（含冒号的是引用，不是实体名！）

## 【重要】关系验证规则

6. **避免类主节点连接**: 
   - 检查所有关系，确保没有直接连接到类主节点（泛型类）
   - 类主节点示例：单独的"购物平台"、"社交平台"、"应用"等（没有具体实体名称）
   - ❌ 错误：{{"source": "我", "target": "购物平台"}} - "购物平台"是类主节点
   - ✅ 正确：{{"source": "我", "target": "小红书:购物平台"}} - 连接到具体实体的类节点
   - 如果发现这样的关系，应该：
     a. 优先找到或创建具体的实体，将关系连接到该实体或其类节点
     b. 如果无法确定具体实体，标记为"skip"并在reason中说明

7. **动作事件为关系，非实体**:
   - 检查是否有动作或事件被作为实体
   - 动作性事件（如"购买"、"浏览"、"联系"）应该是关系的描述，不应该是实体
   - 只有重大名词化事件（如"春节"、"产品发布会"）才应作为实体
   - 如果发现动作性事件作为实体，应标记为"skip"或转换为关系

8. **【强制】优先使用实体类节点（entity:class）而非纯实体节点**:
   - 检查所有关系的source和target
   - 如果关系涉及实体的特定功能，必须使用 "实体名:类名" 格式
   - ✅ 正确：{{"source": "我", "target": "高德地图:地图应用"}} - 使用地图功能
   - ❌ 错误：{{"source": "我", "target": "高德地图"}} - 应该明确标识功能
   - 只有整体性关系（如"我喜欢某实体"）才使用纯实体节点
   - 处理步骤：
     a. 分析关系描述，判断是否涉及特定功能
     b. 如果涉及特定功能，检查实体是否有对应的类
     c. 将关系修改为使用 "实体名:类名" 格式
     d. 在reason中说明优化原因

9. **【关键】Refer字段决定关系唯一性 & INCREMENT_COUNT操作**:
   - **关系唯一性判断**：source + target + description + **refer** 都相同才是同一关系
   - **合并规则 - 使用increment_count操作**：
     - ✅ 相同关系（应使用increment_count操作）：
       - 现有关系: "我 -> 微信:可启动应用", description="打开了应用", refer=[], count=3
       - 增量关系: "我 -> 微信:可启动应用", description="启动应用", refer=[], count=1
       - → 输出: operation="increment_count", increment_amount=1, reason="与现有关系完全相同，累加count"
       - → 结果: 现有关系的count从3变为4
     - ✅ 批量相同关系（一次性累加多次）：
       - 现有关系: "我 -> 淘宝:可启动应用", description="我打开应用", refer=[], count=5
       - 增量关系: "我 -> 淘宝:可启动应用", description="打开淘宝", refer=[], count=3
       - → 输出: operation="increment_count", increment_amount=3, reason="他们语义相同，与现有关系完全相同，累加count 3次"
       - → 结果: 现有关系的count从5变为8
     - ❌ 不同关系（不可合并，应使用add操作）：
       - 现有关系: "我 -> 小明:可联系人", description="联系小明", refer=["问作业"], count=1
       - 增量关系: "我 -> 小明:可联系人", description="联系小明", refer=["微信:交流平台","分享视频"], count=1
       - → 输出: operation="add"（保持为两条独立关系，因为 refer 不同）
   - **INCREMENT_COUNT 操作详细说明**：
     - **何时使用**: 当增量关系与现有关系的 source、target、description、refer 完全相同时
     - **increment_amount字段**: 表示要增加的次数（通常等于增量关系的count值）
     - **典型场景**: 重复的原子操作（如多次打开同一应用、多次访问同一地点）
     - **语义验证**: 必须确保两个关系在语义上完全相同，不仅是字面相同
     - **输出要求**:
       - operation: "increment_count"
       - increment_amount: 要增加的次数（正整数）
       - 保持原有的 source、target、description、refer 不变
       - reason 中说明是与哪个现有关系匹配，以及累加的次数
   - **Refer字段处理**：
     - 输出时必须包含 "refer" 字段
     - 如果没有其他参与实体，使用空数组 []
     - Refer中的实体必须在现有图谱或增量中存在
     - 合并时比较 refer 数组内容（顺序无关，但内容必须完全一致）
     - refer 不同则视为不同关系，不能使用 increment_count

10. **【理解】原子关系 vs 复杂关系**:
    - **原子关系**: 单一直接动作，refer=[]
      - 示例: "我 -> 微信:可启动应用" (打开微信)
      - 示例: "视频:内容 -> 小明:可联系人" (分享视频给小明)
      - **特点**: 最适合使用 increment_count 操作累加次数
    - **复杂关系**: 多方参与的事件，refer=[其他实体]
      - 示例: "微信:交流平台 -> 小明:可联系人", refer=["视频:内容"] (通过微信把视频分享给小明)
      - **注意**: 即使source、target、description相同，只要refer不同就是不同关系，不能使用increment_count
    - **共存原则**: 原子关系和复杂关系应该共存，不是互相替换
    - **合并注意**: 不要将原子关系和复杂关系错误地合并在一起

10.5. **【重要】语义时间（semantic_times）处理规则**:
    - **定义**: semantic_times记录关系所表示事件的发生时间（区别于系统的created_at/updated_at）
    - **格式**: ISO 8601格式字符串列表，如 `["2026-01-10T10:30:00", "2026-01-10T15:00:00"]`
    - **处理规则**:
      - 时间列表可以为空（`[]`），表示没有具体时间信息
      - 时间列表长度可以小于count（允许部分事件没有时间）
      - 时间格式必须符合ISO 8601标准
      - increment_count时，增量关系的semantic_times追加到现有关系的时间列表
    - **示例**:
      - 现有关系: semantic_times=`["2026-01-09T10:00:00", "2026-01-09T15:00:00"]`
      - 增量关系: semantic_times=`["2026-01-10T08:30:00"]`
      - increment_count后: 输出semantic_times=`["2026-01-10T08:30:00"]`（只包含新时间）
      - 应用后效果: 现有关系的semantic_times变为`["2026-01-09T10:00:00", "2026-01-09T15:00:00", "2026-01-10T08:30:00"]`

11. **【示例】INCREMENT_COUNT操作的正确使用**:
    
    **场景1: 简单原子操作累加（带语义时间）**
    - 现有关系: {{"source": "我", "target": "高德地图:地图应用", "description": "打开高德地图", "refer": [], "count": 5, "semantic_times": ["2026-01-09T10:00:00", "2026-01-09T15:30:00"]}}
    - 增量关系: {{"source": "我", "target": "高德地图:地图应用", "description": "我打开了高德地图", "refer": [], "count": 2, "semantic_times": ["2026-01-10T08:30:00"]}}
    - 分析: source、target、description（语义上相同）、refer 完全相同，这是同一个原子操作重复2次，增量中有1个新时间
    - **正确输出**:
      ```json
      {{
        "source": "我",
        "target": "高德地图:地图应用",
        "description": "打开高德地图",
        "refer": [],
        "count": 5,
        "semantic_times": ["2026-01-10T08:30:00"],
        "operation": "increment_count",
        "increment_amount": 2,
        "reason": "与现有关系完全相同（source、target、description、refer均相同），累加count 2次（总count将从5变为7），并追加1个语义时间"
      }}
      ```
    - **注意**: semantic_times中只包含增量关系的新时间，应用时会追加到现有关系的时间列表
    
    **场景2: 不能使用increment_count的情况**
    - 现有关系: {{"source": "我", "target": "小明:可联系人", "description": "联系小明", "refer": ["问作业"], "count": 1, "semantic_times": ["2026-01-09T14:00:00"]}}
    - 增量关系: {{"source": "我", "target": "小明:可联系人", "description": "联系小明", "refer": ["分享视频"], "count": 1, "semantic_times": ["2026-01-10T16:00:00"]}}
    - 分析: source、target、description 相同，但 refer 不同（问作业 vs 分享视频），这是两次不同目的的联系
    - **正确输出**:
      ```json
      {{
        "source": "我",
        "target": "小明:可联系人",
        "description": "联系小明",
        "refer": ["分享视频"],
        "count": 1,
        "semantic_times": ["2026-01-10T16:00:00"],
        "operation": "add",
        "increment_amount": 0,
        "reason": "虽然source、target、description与现有关系相同，但refer不同，这是不同目的的联系，应作为新关系添加"
      }}
      ```
    
    **场景3: 完全相同但count为1的情况（无语义时间）**
    - 现有关系: {{"source": "我", "target": "微信:可启动应用", "description": "打开微信", "refer": [], "count": 10, "semantic_times": []}}
    - 增量关系: {{"source": "我", "target": "微信:可启动应用", "description": "打开了微信", "refer": [], "count": 1, "semantic_times": []}}
    - 分析: 完全相同的原子操作，增量中只记录了1次，都没有时间信息
    - **正确输出**:
      ```json
      {{
        "source": "我",
        "target": "微信:可启动应用",
        "description": "打开微信",
        "refer": [],
        "count": 10,
        "semantic_times": [],
        "operation": "increment_count",
        "increment_amount": 1,
        "reason": "与现有关系完全相同，累加count 1次，总count将从10变为11"
      }}
      ```
    - **注意**: semantic_times可以为空列表，表示没有具体时间信息

## 【示例】如何使用提供的数据进行合并

### 示例输入数据

**Delta相关的现有数据（搜索结果）**:
```json
[
  {{
    "name": "美团外卖",
    "description": "外卖订餐平台",
    "classes": ["可启动应用"],
    "properties": {{}},
    "search_score": 0.95,
    "matched_by": "美团外卖"
  }},
  {{
    "name": "微信",
    "description": "即时通讯应用",
    "classes": ["可启动应用", "交流平台"],
    "properties": {{}},
    "search_score": 0.98,
    "matched_by": "微信"
  }}
]
```

**待合并的Delta**:
```json
{{
  "entities": [
    {{"name": "美团外卖", "classes": ["可启动应用", "外卖服务"], "description": "提供外卖点餐服务的应用"}},
    {{"name": "微信", "classes": ["可启动应用", "交流平台"], "description": "社交通讯平台"}},
    {{"name": "张三餐厅", "classes": ["餐厅"], "description": "一家餐厅"}}
  ],
  "relationships": [
    {{"source": "我", "target": "美团外卖:可启动应用", "description": "我打开美团外卖", "count": 1}}
  ]
}}
```

### 正确的分析流程

1. **分析"美团外卖"**:
   - 在Delta相关数据中找到"美团外卖"，search_score=0.95（很高）
   - 名称完全相同，说明实体已存在
   - 现有类:["可启动应用"]，Delta类:["可启动应用", "外卖服务"]
   - **决策**: operation="update"，添加新类"外卖服务"，合并描述

2. **分析"微信"**:
   - 在Delta相关数据中找到"微信"，search_score=0.98（非常高）
   - 名称完全相同，类完全相同
   - **决策**: operation="skip"或"update"（优化描述）

3. **分析"张三餐厅"**:
   - 在Delta相关数据中未找到（如果搜索结果中没有）
   - 在所有现有实体中检查，如果也没有
   - **决策**: operation="add"，新实体

### 错误示例（避免）

❌ **错误1**: 不查看搜索结果，直接将已存在的实体标记为"add"
```json
{{"name": "美团外卖", "operation": "add"}}  // 错误！应该是update
```

❌ **错误2**: 忽略search_score，错误判断实体不存在
```json
// Delta相关数据中明明有search_score=0.95的"美团外卖"
{{"name": "美团外卖", "operation": "add", "reason": "新实体"}}  // 错误！
```

❌ **错误3**: 没有利用matched_by信息
```json
// 没有注意到"美团外卖"的matched_by="美团外卖"，说明是同名匹配
{{"name": "美团外卖", "operation": "add"}}  // 错误！
```

✅ **正确做法**:
```json
{{
  "optimized_entities": [
    {{
      "name": "美团外卖",
      "description": "提供外卖点餐服务的应用平台",
      "classes": ["可启动应用", "外卖服务"],
      "properties": {{}},
      "operation": "update",
      "merge_target": null,
      "reason": "实体已存在（search_score=0.95），新增'外卖服务'类，优化描述"
    }},
    {{
      "name": "微信",
      "description": "社交通讯平台",
      "classes": ["可启动应用", "交流平台"],
      "properties": {{}},
      "operation": "update",
      "merge_target": null,
      "reason": "实体已存在（search_score=0.98），类相同，优化描述"
    }},
    {{
      "name": "张三餐厅",
      "description": "一家餐厅",
      "classes": ["餐厅"],
      "properties": {{}},
      "operation": "add",
      "merge_target": null,
      "reason": "新实体，在现有数据和搜索结果中均未找到"
    }}
  ]
}}
```

## 开始任务

请充分利用"所有现有实体详情"和"Delta相关的现有数据"，仔细分析待合并的增量更新，输出优化后的结果。
